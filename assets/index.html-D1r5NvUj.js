import{_ as t,c as l,a as i,b as a,d as n,e as p,g as d,o}from"./app-CrDOs8BQ.js";const r={};function h(c,s){const e=d("Folder");return o(),l("div",null,[s[4]||(s[4]=i(`<h2 id="一、什么是-node-js" tabindex="-1"><a class="header-anchor" href="#一、什么是-node-js"><span>一、什么是 Node.js</span></a></h2><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时环境，可以用来开发服务器端和网络应用。</p><ol><li><strong>非阻塞和事件驱动</strong>：Node.js 使用事件驱动和异步编程模型，<strong>能够处理大量并发请求</strong>，提高了应用程序的性能和吞吐量。</li><li><strong>单线程</strong>：Node.js 使用单线程的事件循环机制，通过非阻塞 I/O 操作实现高并发处理。</li><li><strong>轻量和高效</strong>：Node.js 运行时环境很轻量，启动快速，并且能够处理大量的并发连接。</li><li><strong>跨平台</strong>：Node.js 可以在多个操作系统上运行，如 Windows、Mac 和 Linux。</li><li><strong>丰富的模块生态系统</strong>：Node.js 拥有丰富的模块和包管理器 npm，可以方便地引用和管理各种功能模块。</li><li><strong>可扩展性</strong>：Node.js 通过模块化的方式支持代码的重用和组件化开发，使得应用程序易于扩展和维护。</li></ol><p>通过这些特点，Node.js 成为了开发高性能、高并发的网络应用和服务器端应用的首选。</p><div class="hint-container tip"><p class="hint-container-title">主要用途和功能：</p><ol><li>‌<strong>服务器端开发</strong>‌：Node.js 主要用于构建高性能、高并发的网络服务器，如 HTTP 服务器。‌2</li><li>‌<strong>实时应用</strong>‌：适合于开发实时交互应用，如聊天室、实时协作工具等。</li><li>‌<strong>API 服务</strong>‌：常用于构建 RESTful API 服务器。</li><li>‌<strong>工具脚本</strong>‌：可以用来编写各种自动化脚本和命令行工具。</li></ol></div><div class="hint-container tip"><p class="hint-container-title">性能优化</p><ul><li><strong>非阻塞 I/O</strong>：Node.js 是基于事件驱动和非阻塞 I/O 模型的，这意味着它可以同时处理大量的并发请求。通过使用回调函数和事件监听器，Node.js 可以在等待 I/O 操作完成时继续处理其他请求，从而提高性能和吞吐量。</li><li><strong>异步编程</strong>：利用 JavaScript 的异步编程能力，可以通过使用异步 API、Promise 和 async/await 等技术，避免阻塞操作，提高代码的执行效率和响应能力。</li><li><strong>多进程和集群</strong>：使用 Node.js 的集群模块（例如<code>cluster</code>模块）可以创建多个工作进程，以利用多核处理器和额外的计算资源，提高性能和负载均衡能力。</li><li><strong>代码优化</strong>：优化 Node.js 应用程序的代码结构和算法，避免不必要的计算和复杂度高的操作，以提高代码的执行效率和响应速度。</li><li><strong>使用高效的库和工具</strong>：选择高效的第三方库和工具，如 Express.js、Fastify、Redis 等，它们可以提供更好的性能和更高的吞吐量。</li></ul></div><h2 id="二、介绍几个重要概念" tabindex="-1"><a class="header-anchor" href="#二、介绍几个重要概念"><span>二、介绍几个重要概念</span></a></h2><h3 id="_1、npm-包管理器" tabindex="-1"><a class="header-anchor" href="#_1、npm-包管理器"><span>1、NPM 包管理器</span></a></h3><p><code>npm（Node Package Manager）</code> 是 <code>Node.js</code> 的标准包管理器，用于<strong>安装</strong>、<strong>发布</strong>、<strong>管理包依赖关系</strong>、以及<strong>运行某些脚本</strong>。类似于 java 中的 maven。</p><h3 id="_2、阻塞、非阻塞执行" tabindex="-1"><a class="header-anchor" href="#_2、阻塞、非阻塞执行"><span>2、阻塞、非阻塞执行</span></a></h3><p><strong>阻塞</strong> 是当 <code>Node.js</code> 进程中的其他 <code>JavaScript</code> 的执行必须等到非 <code>JavaScript</code> 操作完成时。 发生这种情况是因为在发生 <strong>阻塞</strong> 操作时事件循环无法继续运行 JavaScript。一般来说，常见的阻塞场景，<code>定时器（setInterval）</code>、<code>计时器（setTimeout）</code>、异步请求（<code>Ajax</code>、<code>Promise</code>等）、<code>I/O流</code>等。</p><p><strong>非阻塞执行</strong> 指的是<strong>异步编程</strong>，<code>Node.js</code> 遇到阻塞性的代码时，将其交给操作系统，并立即执行下一条代码，等待操作系统执行完成后，操作系统会通知 <code>Node.Js</code>，然后执行相应的回调函数</p><h3 id="_3、异步编程" tabindex="-1"><a class="header-anchor" href="#_3、异步编程"><span>3、异步编程</span></a></h3><p>在 Node.js 中，异步编程是核心的特性之一，是为了解决<strong>代码阻塞</strong>，<strong>提高运行效率</strong>的重要手段。Node.js 基于 <code>事件循环</code> 、<code>回调函数</code> 机制或 <code>Promises</code>、<code>async/await</code>等<code>Javascript</code>，来实现非阻塞操作。</p><p>异步编程意味着在执行 I/O（输入/输出）操作时，程序不会阻塞当前线程去等待操作完成，而是继续执行其他任务，并在 I/O 操作完成时通过<strong>回调</strong>、<strong>事件监听器</strong>或 <strong>Promise</strong> 的 <strong>then</strong> 方法来处理结果。</p><h3 id="_4、回调" tabindex="-1"><a class="header-anchor" href="#_4、回调"><span>4、回调</span></a></h3><p>回调是一种异步编程的实现。我们通过给阻塞性的函数的传入一个函数作为参数，等该阻塞函数执行完毕时，我们触发该回调函数来实现对结果的处理，这个传入函数叫做<code>回调函数</code>。他可以用来处理异步操作，避免代码阻塞，并且可以进行错误处理，同时也可以一定程度上实现逻辑走向的控制管理</p><div class="language-js line-numbers-mode" data-ext="js" data-title="js"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">//</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">回调函数</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">function</span><span class="space"> </span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">callback</span><span class="space"> </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span class="space"> </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">{</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">....</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">function</span><span class="space"> </span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">doing</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">param</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span class="space"> </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">callback</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span class="space"> </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">{</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">Vue</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">ajax</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">param</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">).</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">then</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">((</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">res</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)=&gt;{</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">//</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">假如</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">Vue.ajax是个异步接口请求</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">callback</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">res</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">//</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">执行回调函数callback，处理结果res</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">})</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_5、事件模块" tabindex="-1"><a class="header-anchor" href="#_5、事件模块"><span>5、事件模块</span></a></h3><p>事件模块和 <code>Node.js</code> 的事件循环是两回事。</p><p>事件模块是作为 Node.js 代码执行层面的一种用来监听事件、触发操作、模块间传递消息的机制。</p><p>而事件循环是 Node.js 框架用来实现并发和异步编程的的一种机制。</p><h3 id="_6、路由和中间件" tabindex="-1"><a class="header-anchor" href="#_6、路由和中间件"><span>6、路由和中间件</span></a></h3><p><strong>路由</strong> 指的是将一个 URL 路径和一个资源的映射关系。路由可以指向服务器中一个确定的静态资源（如网页、css、js、图片等），也可以指向服务器开放的服务接口。</p><p><strong>中间件</strong> 指的是在路由的请求和处理过程中，插入的一段处理逻辑，一般是一个函数或者一组函数，用来执行一些预处理或者后处理操作，比如修改请求报文，处理响应报文，错误处理，身份验证，日志记录。</p><h3 id="_7、缓存" tabindex="-1"><a class="header-anchor" href="#_7、缓存"><span>7、缓存</span></a></h3><ul><li><p><strong>模块缓存：</strong> 我们在引入模块时，<code>Node.js</code> 会先去缓存中寻找该模块，如果找不到就去工程下寻找该模块，找到并引入以后，将依赖放入缓存中。</p></li><li><p><strong>内存缓存：</strong> 内存缓存指的是缓存业务数据，我们可以使用<code>Object</code>和<code>map</code>来实现一个数据对象来临时存放着这些业务数据。</p></li><li><p><strong>数据缓存：</strong> 如果需要实现对<strong>数据库</strong>、<strong>外部 API</strong>、或者一些 <strong>耗时的网络、IO 操作</strong> ，我们可以引入一些第三方库（<code>redis</code>、<code>lru-cache</code>）来解决。</p></li></ul><p>模块缓存是 Node.js 提供的一种包加载的机制，以提高开发过程中寻包的效率，而内存缓存和数据缓存则是业务层面的一种设计。</p><h3 id="_8、线程池" tabindex="-1"><a class="header-anchor" href="#_8、线程池"><span>8、线程池</span></a></h3><p>线程池由 <code>libuv</code> 库处理。<code>libuv</code> 是一个多平台 <strong>C 库</strong>，它支持基于异步 I/O 的操作，例如文件系统、网络和并发。通过线程池可以实现并发处理，提高系统的吞吐量和响应能力。</p><p>线程池利用计算机逻辑核的并行处理能力来执行多个任务，合理配置线程池的大小可以充分利用计算机的多核处理能力，提高系统的并发性和性能‌。</p><p>Node.js是基于单线程事件循环的，但是它使用线程池来处理某些任务，例如CPU密集型操作或需要进行阻塞式I/O的任务。线程池允许Node.js同时执行多个阻塞式操作，而不会阻塞事件循环本身。</p><p>当Node.js需要执行阻塞式I/O或CPU密集型操作时，它会将这些任务委派给线程池中的线程进行处理。这些线程对于Node.js来说是透明的，它们会在后台进行处理，并在完成后将结果返回给事件循环。这样，事件循环就不会被阻塞，其他请求仍然可以得到及时处理和响应。</p><p>总结起来，Node.js通过事件循环和线程池的机制实现了高效的并发处理。事件循环通过非阻塞I/O的方式处理大量并发请求，而线程池可以处理一些需要阻塞式I/O或CPU密集型操作的任务，以保持事件循环的高效运行。</p><h2 id="三、内置变量" tabindex="-1"><a class="header-anchor" href="#三、内置变量"><span>三、内置变量</span></a></h2><h3 id="_1、global" tabindex="-1"><a class="header-anchor" href="#_1、global"><span>1、<code>global</code></span></a></h3><p>Node.js 中的 Global 全局对象，它是所有全局变量的容器</p><h3 id="_2、-dirname" tabindex="-1"><a class="header-anchor" href="#_2、-dirname"><span>2、<code>__dirname</code></span></a></h3><p><code>__dirname</code> 与 require 类似，都是 Node.js 环境中的&#39;全局&#39;变量</p><p><code>__dirname</code> 保存着 当前文件所在目录的绝对路径 ，可以使用 <code>__dirname</code> 与文件名拼接成绝对路径</p><p>代码示例：</p><div class="language-js line-numbers-mode" data-ext="js" data-title="js"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">let</span><span class="space"> </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">data</span><span class="space"> </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span class="space"> </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">fs</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">readFileSync</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">__dirname</span><span class="space"> </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">+</span><span class="space"> </span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">/data.txt</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">console</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">log</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">data</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 <code>fs</code> 模块的时候，尽量使用 <code>__dirname</code> 将路径转化为绝对路径，这样可以避免相对路径产生的 bug</p><h3 id="_3、-filename" tabindex="-1"><a class="header-anchor" href="#_3、-filename"><span>3、<code>__filename</code></span></a></h3>`,44)),a("p",null,[s[0]||(s[0]=a("code",null,"__dirname",-1)),s[1]||(s[1]=n(" 保存着 当前文件的绝对路径。例如：在 ")),p(e,{path:"/Users/mjr"}),s[2]||(s[2]=n("目录下执行该文件 ")),s[3]||(s[3]=a("code",null,"node example.js",-1))]),s[5]||(s[5]=i(`<div class="language-js line-numbers-mode" data-ext="js" data-title="js"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">console</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">log</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">__filename</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">//</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">Prints:</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">/Users/mjr/example.js</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">console</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">log</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">__dirname</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">//</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">Prints:</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">/Users/mjr</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="四、主要的内置模块" tabindex="-1"><a class="header-anchor" href="#四、主要的内置模块"><span>四、主要的内置模块</span></a></h2><p>以下是几个常用的模块：</p><ul><li><code>fs</code>：<strong>文件系统模块</strong>，用于文件的读取、写入、创建、删除等操作，以及文件夹的创建和删除。</li><li><code>path</code>： <strong>路径处理模块</strong>，用于处理和转换指定的文件路径。</li><li><code>http</code>：<strong>HTTP 模块</strong>，用于创建 HTTP 服务器，处理 HTTP 请求。</li><li><code>https</code>：<strong>HTTPS 模块</strong>，用于创建 HTTPS 服务器。</li><li><code>events</code>：<strong>事件模块</strong>，用于 Node.js 事件模型的核心，用于触发和处理事件。</li><li><code>stream</code>：<strong>流模块</strong>，用于流式数据处理。</li><li><code>url</code>：<strong>URL 处理模块</strong>，用于解析 URL 字符串。</li><li><code>util</code>：<strong>实用工具模块</strong>，包含一些常用的工具函数，如<code>util.promisify()</code>等。</li><li><code>zilb</code> ：<strong>压缩模块</strong>，用于实现 Gzip 和 Deflate/Inflate 算法。</li><li><code>os</code>：<strong>操作系统</strong> 用于获取系统信息，如 CPU 、线程和内存使用情况。</li><li><code>crypto</code> ：<strong>加密模块</strong>，用于常见的加密、解密、签名、验证等算法的相关操作。</li></ul>`,4))])}const g=t(r,[["render",h],["__file","index.html.vue"]]),m=JSON.parse('{"path":"/NodeJs/o54fbz4k/","title":"Node.js 简介","lang":"zh-CN","frontmatter":{"title":"Node.js 简介","createTime":"2025/03/15 14:12:39","permalink":"/NodeJs/o54fbz4k/"},"headers":[],"readingTime":{"minutes":8.18,"words":2454},"git":{"updatedTime":1742050940000,"contributors":[{"name":"kangkang shang","username":"kangkang shang","email":"535634238@qq.com","commits":1,"avatar":"https://avatars.githubusercontent.com/kangkang shang?v=4","url":"https://github.com/kangkang shang"}]},"filePathRelative":"notes/NodeJs/1.Node.js 简介.md"}');export{g as comp,m as data};
