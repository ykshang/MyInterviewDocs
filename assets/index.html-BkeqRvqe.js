import{_ as a,c as i,a as n,o as t}from"./app-CrDOs8BQ.js";const p={};function l(e,s){return t(),i("div",null,s[0]||(s[0]=[n('<div class="hint-container tip"><p class="hint-container-title">总结</p><ul><li><strong>栈</strong>：用于存储 <strong>基本数据类型</strong> 和<strong>函数调用栈（指向堆的指针）</strong>，内存分配连续，生命周期短，访问速度快。</li><li><strong>堆</strong>：用于存储<strong>引用数据类型</strong>，内存分配不连续，生命周期长，访问速度较慢。</li></ul></div><p>在 JavaScript 中，<strong>堆（Heap）</strong> 和 <strong>栈（Stack）</strong> 是两种不同的内存分配机制，用于存储和管理数据。它们的主要区别在于存储的内容、生命周期以及访问方式。以下是堆和栈的详细对比：</p><h3 id="_1-栈-stack" tabindex="-1"><a class="header-anchor" href="#_1-栈-stack"><span>1. <strong>栈（Stack）</strong></span></a></h3><table><thead><tr><th>特点</th><th>介绍</th></tr></thead><tbody><tr><td>存储内容</td><td>栈用于存储<strong>基本数据类型</strong>（如 <code>number</code>、<code>string</code>、<code>boolean</code>、<code>null</code>、<code>undefined</code>、<code>symbol</code>）以及<strong>函数的调用栈</strong>（如函数调用时的局部变量、参数、返回地址等）。</td></tr><tr><td>内存分配</td><td>栈的内存分配是连续的，由系统自动管理。</td></tr><tr><td>生命周期</td><td>栈中的数据生命周期与函数的执行周期一致。当函数执行完毕，栈中的数据会自动释放。</td></tr><tr><td>访问速度</td><td>栈的访问速度非常快，因为内存是连续的，且大小固定。</td></tr><tr><td>大小限制</td><td>栈的大小通常较小（由系统或浏览器限制），如果栈空间不足，会导致 <strong>栈溢出（Stack Overflow）</strong>。</td></tr></tbody></table><h4 id="示例" tabindex="-1"><a class="header-anchor" href="#示例"><span>示例：</span></a></h4><div class="language-javascript line-numbers-mode" data-ext="javascript" data-title="javascript"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">function</span><span class="space"> </span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">foo</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span class="space"> </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">{</span></span>\n<span class="line"><span class="space"> </span><span class="space"> </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">let</span><span class="space"> </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">a</span><span class="space"> </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span class="space"> </span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">10</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">//</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">`a`</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">存储在栈中</span></span>\n<span class="line"><span class="space"> </span><span class="space"> </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">let</span><span class="space"> </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">b</span><span class="space"> </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span class="space"> </span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">20</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">//</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">`b`</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">存储在栈中</span></span>\n<span class="line"><span class="space"> </span><span class="space"> </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">return</span><span class="space"> </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">a</span><span class="space"> </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">+</span><span class="space"> </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">b</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>\n<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span>\n<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">//</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">foo在栈里，值是一个指针，指向堆</span></span>\n<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">foo</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">//</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">函数执行完毕后，`a`</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">和</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">`b`</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">从栈中释放</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-堆-heap" tabindex="-1"><a class="header-anchor" href="#_2-堆-heap"><span>2. <strong>堆（Heap）</strong></span></a></h3><h4 id="特点" tabindex="-1"><a class="header-anchor" href="#特点"><span>特点：</span></a></h4><ul><li><strong>存储内容</strong>： <ul><li>堆用于存储<strong>引用数据类型</strong>（如对象、数组、函数等）。</li></ul></li><li><strong>内存分配</strong>： <ul><li>堆的内存分配是不连续的，由开发者或垃圾回收机制管理。</li></ul></li><li><strong>生命周期</strong>： <ul><li>堆中的数据生命周期不确定，直到没有任何引用指向它时，才会被垃圾回收机制回收。</li></ul></li><li><strong>访问速度</strong>： <ul><li>堆的访问速度较慢，因为内存是不连续的，需要通过指针（引用）访问。</li></ul></li><li><strong>大小限制</strong>： <ul><li>堆的大小通常较大，可以动态分配内存。</li></ul></li></ul><h4 id="示例-1" tabindex="-1"><a class="header-anchor" href="#示例-1"><span>示例：</span></a></h4><div class="language-javascript line-numbers-mode" data-ext="javascript" data-title="javascript"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">let</span><span class="space"> </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">obj</span><span class="space"> </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span class="space"> </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">{</span><span class="space"> </span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">name</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span class="space"> </span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">Alice</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span class="space"> </span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">age</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span class="space"> </span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">25</span><span class="space"> </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">};</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">//</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">`obj`</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">的引用存储在栈中，实际对象存储在堆中</span></span>\n<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">let</span><span class="space"> </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">arr</span><span class="space"> </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span class="space"> </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span class="space"> </span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span class="space"> </span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">3</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">];</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">//</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">`arr`</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">的引用存储在栈中，实际数组存储在堆中</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_3-堆和栈的区别总结" tabindex="-1"><a class="header-anchor" href="#_3-堆和栈的区别总结"><span>3. <strong>堆和栈的区别总结</strong></span></a></h3><table><thead><tr><th>特性</th><th>栈（Stack）</th><th>堆（Heap）</th></tr></thead><tbody><tr><td><strong>存储内容</strong></td><td>基本数据类型、函数调用栈</td><td>引用数据类型（对象、数组等）</td></tr><tr><td><strong>内存分配</strong></td><td>连续内存，系统自动管理</td><td>不连续内存，动态分配</td></tr><tr><td><strong>生命周期</strong></td><td>与函数执行周期一致，自动释放</td><td>由垃圾回收机制管理，生命周期不确定</td></tr><tr><td><strong>访问速度</strong></td><td>快</td><td>慢</td></tr><tr><td><strong>大小限制</strong></td><td>较小，容易栈溢出</td><td>较大，可以动态扩展</td></tr><tr><td><strong>管理方式</strong></td><td>系统自动管理</td><td>开发者或垃圾回收机制管理</td></tr></tbody></table><h3 id="_4-堆和栈的协作" tabindex="-1"><a class="header-anchor" href="#_4-堆和栈的协作"><span>4. <strong>堆和栈的协作</strong></span></a></h3><ul><li>在 JavaScript 中，栈和堆是协同工作的： <ul><li><strong>栈</strong>存储基本数据类型和引用类型的指针（地址）。</li><li><strong>堆</strong>存储引用类型的实际数据。</li></ul></li><li>例如：<div class="language-javascript line-numbers-mode" data-ext="javascript" data-title="javascript"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">let</span><span class="space"> </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">a</span><span class="space"> </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span class="space"> </span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">10</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">//</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">`a`</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">是基本数据类型，存储在栈中</span></span>\n<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">let</span><span class="space"> </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">b</span><span class="space"> </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span class="space"> </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">{</span><span class="space"> </span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">name</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span class="space"> </span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">Bob</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span class="space"> </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">};</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">//</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">`b`</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">是引用类型，`b`</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">的指针存储在栈中，实际对象存储在堆中</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="_5-垃圾回收机制" tabindex="-1"><a class="header-anchor" href="#_5-垃圾回收机制"><span>5. <strong>垃圾回收机制</strong></span></a></h3><ul><li><strong>栈</strong>：栈中的数据在函数执行完毕后会自动释放，无需垃圾回收。</li><li><strong>堆</strong>：堆中的数据由垃圾回收机制（如 V8 引擎的标记-清除算法）管理，当对象不再被引用时，会被回收。</li></ul><h3 id="_6-实际应用中的注意事项" tabindex="-1"><a class="header-anchor" href="#_6-实际应用中的注意事项"><span>6. <strong>实际应用中的注意事项</strong></span></a></h3><ul><li><strong>栈溢出</strong>： <ul><li>如果递归调用过深，可能导致栈溢出。</li><li>解决方法：将递归改为循环，或使用尾递归优化。</li></ul></li><li><strong>内存泄漏</strong>： <ul><li>如果堆中的对象不再使用但仍被引用，会导致内存泄漏。</li><li>解决方法：及时释放不再使用的对象引用。</li></ul></li></ul>',20)]))}const r=a(p,[["render",l],["__file","index.html.vue"]]),k=JSON.parse('{"path":"/WebBasic/66oba1g1/","title":"堆和栈的区别","lang":"zh-CN","frontmatter":{"title":"堆和栈的区别","createTime":"2025/03/15 13:21:27","permalink":"/WebBasic/66oba1g1/"},"headers":[],"readingTime":{"minutes":3.3,"words":990},"git":{"updatedTime":1742050940000,"contributors":[{"name":"kangkang shang","username":"kangkang shang","email":"535634238@qq.com","commits":1,"avatar":"https://avatars.githubusercontent.com/kangkang shang?v=4","url":"https://github.com/kangkang shang"}]},"filePathRelative":"notes/Javascript/1.基础知识/28.堆和栈的区别.md"}');export{r as comp,k as data};
